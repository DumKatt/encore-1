--
-- data Par t = Stop                   -- empty structures
--             | V t                    -- a single value, here
--             | F (Fut t)              -- single value, not yet here
--             | P (Par t) (Par t)  -- par

passive class T  -- represents the type variable for RepParT

passive class RepParT {
  typetag : int
  -- union 
  -- S -- typetag == 0
  -- V -- typetag == 1
  _val : T
  -- F -- typetag == 2
  _future : Fut t
  -- P -- typetag == 3
  _left : RepParT
  _right : RepParT

  def init() {
    -- can't do much here, maybe set everything to null
  }
  
  -- S ops
  def mkS() : RepParT {
    this.typetag = 0;
    this;
  }

  def isS() : boolean {
     (typetag == 0);
  }

  -- V ops
  def mkV(x : T) : RepParT {
    this.typetag = 1;
    this._val = x;
    this;
  }

  def isV() : boolean {
     (typetag == 1);
  }

  def val() : T {
     this._val;
  }
   
  -- F ops
  def mkF(x : Fut T) : ReParT {
    this.typetag = 2;
    this._future = x;
    this;
  }

  def isF() : boolean {
     (typetag == 2);
  }

  def future() : Fut T {
     this._future;
  }  

  -- P ops
  def mkP(x : RepParT, y : RepParT) : RepParT {
    this.typetag = 3;
    this._left = x;
    this._right = y;
    this;
  }

  def isP() : boolean {
     (typetag == 3);
  }

  def left() : RepParT {
     this._left;
  }

  def right() : RepParT {
     this._right;
  }
}

-- The value that signals the stop of a computation. 
-- stop :: Par T
def stop() : RepParT {
  let r = new RepParT in 
    r.mkS();
}


-- "Upcast" a future value into a (singleton) parallel computation.
-- lift :: Fut x -> Par x
def lift(x : Fut T) : RepParT {
  let r = new RepParT in 
    r.mkF(x);
}

-- "Upcast" a value into a (singleton) parallel computation.
-- parone :: x -> Par x
def parone(x : T) : RepParT {
  let r = new RepParT in 
    r.mkV(x);
}


-- (|) :: Par x -> Par x -> Par x
def par(x : RepParT, y : RepPart) : RepParT {
  let r = new RepParT in 
    r.mkP(x,y);
}


-- >>= :: Par x -> (x -> Par y) -> Par y
def bind(x : RepParT, f : T -> RepParT) : RepParT {
  if x.isS() then mkS()
  else if x.isV() then f(x.val())
  else if x.isF() then f(get x.future())
  else mkP(bind(x.left(), f), bind(x.right(), f) )
}




-- A "lambda guarded" value of type t
-- type Delay t = () -> t
-- pruning
(<<) :: (t -> Par t') -> Par t -> Par t'
(<<) = undefined

-- otherwise: if first argument is Stop, use second argument
(\\) :: Par t -> Delay (Par t) -> Par t
(\\) = undefined

seq :: Par t -> [Fut t]
seq = undefined

join :: [Fut t] -> Fut [t]
join = undefined

each :: [t] -> Par t
each = undefined

-- pmap f par applies the function f to all computation of par.
pmap :: Par t -> (t -> t') -> Par t'
pmap = undefined

-- Put all the results of the arguments into a list that will be
-- available when all values are available
sync :: Par t -> Fut [t]
sync = undefined


-- forkJoin f l lifts each element of l into a Par, maps f over that
-- Par, syncs the Par into a list future (possibly of a different size
-- and permutation than l) and gets that future.
forkJoin :: (t -> t') -> [t] -> [t']
forkJoin f = get . sync . pmap f . each



-- Wait for one value to finish and kill any remaining parallel
-- computations.
prune :: Par t -> Fut t
prune = undefined
-- Comment: Note that the type allows directly picking one computation
-- at random and killing the rest.  The type Par t -> t better
-- reflects that we need a value before we are able to kill everyone
-- else


{-
	Some other relevant types are:

	type Consumer t = exists t' . t -> t'

	data Fut t = Fut (Maybe t) (Bag (Consumer t))



>> :: Par t -> (t -> Par t') -> Par t'
-- In f >x> g, g should be seen as a function that depends on some
-- value x :: t. Each value produced by the parallel computation f is
-- passed to g, together producing a new parallel computation of type
-- t'.

<< :: (Fut t -> Par t') -> Par t -> Par t'
-- In f <x< g, f should be seen as a function that depends on some
-- value Fut x. f can start running directly, and it is the job of g
-- to give the future a value. f will sync on the future when
-- necessary. As soon as the future has been filled by one of the
-- parallel computations of g, all other computations of g are killed.
f << g = f (prune g)

| :: Par t -> Par t -> Par t
-- Merge two parallel computations (each of which may be arbitrarily
-- large)

; :: Par t -> Delay(Par t) -> Par t
-- In f; g, if all the computations of f results in stop, run g
-- instead. Note that g is delayed, it does not run until all
-- computations of f has halted.


each :: [t] -> Par t
each [] = stop
each (f:r) = lift . fut f | each r


filter :: (t -> bool) -> Par t -> Par t
-- filter p par kills all computations of par that do not fulfill the
-- condititon p

reduce :: (t -> t' -> t') -> t' -> Par t -> Fut t'
-- reduce works like a fold over a parallel computation, with the
-- second argument being the initial accumulator value. Returns
-- directly with a future

repeat :: Delay t -> Par t
-- Calls the argument function repeatedly, putting all the resulting
-- computations into a par. The following code gives intuition but
-- skips the fact that no new computations are done after f halts for
-- the first time.
repeat f = f() | repeat f

-- Comment: Letting f have the type Delay Maybe t, we can stop when it
-- returns Nothing

iterate :: Par t -> (Par t -> Par t) -> (Par t -> bool) -> Par t
iterate par f p = iterate f p (filter p (pmap f p))
-- The above code is a possible interpretation (I should ask Dave
-- about this... "Do until..." he says). The idea is to keep mapping f
-- over par and keep only the computations for which p results in
-- true. The question is when you should stop... In a functional
-- setting, an implementation could say that you can stop iterating
-- over a value when the resulting value is the same.

scan :: (t -> t' -> t') -> t' -> Par t -> Par t'
-- Like reduce, but produces all intermediate values:
-- scan f z (a | b | ...) = (z | f(a,z) | f(b, f(a,z)) | ...)

-- Comment: scan doesn't really make a lot of sense. Since there is no
-- order in a Par, there will be no order among the intermediate
-- values. If we take optimizations into account, there may be several
-- parallel reductions going at once, so not only will the
-- intermediate values and their order be non-deterministic, but also
-- the size of the resulting Par. The lack of order also means that
-- there is no way to discern between the final value and another one,
-- except that the final one finishes last (something that we most
-- probably can't observe). All we can do (right now) is to prune the
-- resulting Par and hope that we get a "good" value out of it.


-- Consider the following function:

double :: t -> Par t
double x = lift . fut x | lift . fut x
-- The call forkJoin double [1,2,3] will result in any permutation of
-- the list [1, 1, 2, 2, 3, 3]. Do we have a way to express a parallel
-- map that is order (and length) preserving?


parmap :: (t -> t') -> [t] -> [t']
parmap f [] = []
parmap f x:xs = x' : (parmap f xs) << f x
-- Note that the function body (f x) : (parmap f xs') is parallel by
-- construction in Vanilla Orc due to Orc rewriting it into 
--     (x' : xs' <x'< f x )<xs'< parmap f xs

-}