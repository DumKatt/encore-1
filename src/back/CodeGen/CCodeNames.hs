{-|
Defines how things will be called in the CCode generated by CodeGen.hs
Provides mappings from class/method names to their C-name.

The purpose of this module is to

 - get one central place where identifiers in the generated code can be changed

 - ease following of good conventions (ie use @Ptr char@ instead of @Embed "char*"@)

-}

module CodeGen.CCodeNames where

import qualified Identifiers as ID
import Types as Ty
import CCode.Main
import Data.Char

char = Typ "char"
int = Typ "int64_t"
uint = Typ "uint64_t"
bool = Typ "int64_t" -- For pony argument tag compatibility. Should be changed to something smaller
double = Typ "double"
void = Typ "void"
encore_actor_t = Typ "encore_actor_t"
pony_type_t = Typ "pony_type_t"
pony_actor_t = Typ "pony_actor_t"
pony_actor_type_t = Typ "pony_actor_type_t"
pony_arg_t = Typ "pony_arg_t"
pony_msg_t = Typ "pony_msg_t"
enc_msg_t = Typ "encore_fut_msg_t"
enc_oneway_msg_t = Typ "encore_oneway_msg_t"
closure = Ptr $ Typ "closure_t"
future = Ptr $ Typ "future_t"
stream = Ptr $ Typ "stream_t"
unit :: CCode Lval
unit = Embed "UNIT" 

-- | each method is implemented as a function with a `this`
-- pointer. This is the name of that function
method_impl_name :: Ty.Type -> ID.Name -> CCode Name
method_impl_name clazz mname =
    Nam $ (Ty.getId clazz) ++ "_" ++ (show mname)

global_closure_name :: ID.Name -> CCode Name
global_closure_name funname =
    Nam $ (show funname)

global_function_name :: ID.Name -> CCode Name
global_function_name funname = 
    Nam $ "_enc__global_" ++ (show funname) ++ "_fun"

closure_fun_name :: String -> CCode Name
closure_fun_name name =
    Nam $ "_enc__" ++ name ++ "_fun"

closure_env_name :: String -> CCode Name
closure_env_name name =
    Nam $ "_enc__" ++ name ++ "_env"

closure_trace_name :: String -> CCode Name
closure_trace_name name =
    Nam $ "_enc__" ++ name ++ "_trace"

stream_handle :: CCode Lval
stream_handle = Var "_stream"

-- | each class, in C, provides a dispatch function that dispatches
-- messages to the right method calls. This is the name of that
-- function.
class_dispatch_name :: Ty.Type -> CCode Name
class_dispatch_name clazz = Nam $ "_enc__" ++ Ty.getId clazz ++ "_dispatch"

class_message_type_name :: Ty.Type -> CCode Name
class_message_type_name clazz = Nam $ Ty.getId clazz ++ "_message_type"

class_trace_fn_name :: Ty.Type -> CCode Name
class_trace_fn_name clazz = Nam $ "_enc__" ++ Ty.getId clazz ++ "_trace"

method_message_type_name :: Ty.Type -> ID.Name -> CCode Lval --fixme should be a name
method_message_type_name cls mname = 
    Var $ "_ENC__FUT_MSG_" ++ Ty.getId cls ++ "_" ++ show mname

one_way_message_type_name :: Ty.Type -> ID.Name -> CCode Lval --fixme should be a name
one_way_message_type_name cls mname = 
    Var $ "_ENC__ONE_WAY_MSG_" ++ Ty.getId cls ++ "_" ++ show mname

-- | for each method, there's a corresponding message, this is its name
method_msg_name :: Ty.Type -> ID.Name -> CCode Name
method_msg_name cls mname = 
    Nam $ "_ENC__MSG_" ++ Ty.getId cls ++ "_" ++ show mname

one_way_send_msg_name :: Ty.Type -> ID.Name -> CCode Name
one_way_send_msg_name cls mname = 
    Nam $ "_ENC__MSG_" ++ Ty.getId cls ++ "_" ++ show mname

class_type_name :: Ty.Type -> CCode Name
class_type_name cls 
    | Ty.isActiveRefType cls =
        Nam $ "_enc__active_" ++ Ty.getId cls ++ "_t"
    | Ty.isPassiveRefType cls =
        Nam $ "_enc__passive_" ++ Ty.getId cls ++ "_t"
    | otherwise = error $ "Type '" ++ show cls ++ 
                          "' is neither active nor passive!" 

runtime_type_name :: Ty.Type -> CCode Name
runtime_type_name cls 
    | Ty.isActiveRefType cls =
        Nam $ "_enc__active_" ++ Ty.getId cls ++ "_type"
    | Ty.isPassiveRefType cls =
        Nam $ "_enc__passive_" ++ Ty.getId cls ++ "_type"
    | otherwise = error $ "Type '" ++ show cls ++ 
                          "' is neither active nor passive!" 

future_type_rec_name :: CCode Name
future_type_rec_name = Nam $ "future_type"

closure_type_rec_name :: CCode Name
closure_type_rec_name = Nam $ "closure_type"
