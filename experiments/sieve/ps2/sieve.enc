-- /////////////// TODO ////////////////////
-- [ ] Send primes in batches
-- [ ] Make sure to satisfy (No candidates / no actors) squared > no candidates
-- [ ] Future-less void calls 
-- [ ] Only consider odd candidates

-----------------------------------------------------------------------------
-- Dummy class for embedding
-----------------------------------------------------------------------------
passive class Void

-----------------------------------------------------------------------------
-- PrimeArray
-----------------------------------------------------------------------------
passive class PrimeArray
  data : Void 
  work_counter : int
  def report_work() : void
    this.work_counter = this.work_counter + 1
  def get_work_report() : int
    this.work_counter
  def flag(index : int) : void
    embed void
      set((bitset*) (this->data), #{index});
    end
  def unflag(index : int) : void
    embed void
      unset((bitset*) (this->data), #{index});
    end
  def is_not_flagged(index : int) : bool 
    embed bool
      !isset((bitset*) (this->data), #{index});
    end
  def set_size(size : int) : void 
    this.data = embed Void
        (Void_data*) mkBitset(0);
    end
  def bit_index(a : int, b : int) : int 
    embed int
      (#{a} % #{b}) ? ((#{a}/#{b})+1) * #{b} - #{a} : 0;
    end
  def puts(x : int) : void
    print x
  def puts_buf(x : int) : void
    -- TODO: add flushing
    embed void
      static int64_t buf[16]; 
      static short counter = 0;
      if (counter < 16) {
        buf[counter++] = x;
      } else {
        printf("%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n%lld\n", 
               buf[0],
               buf[1],
               buf[2],
               buf[3],
               buf[4],
               buf[5],
               buf[6],
               buf[7],
               buf[8],
               buf[9],
               buf[10],
               buf[11],
               buf[12],
               buf[13],
               buf[14],
               buf[15]);
        counter=0;
      }
    end
  def puts_debug(s : string, i : int) : void
    embed void
      fprintf(stderr, "%s: %lld\n", #{s}, #{i});
    end


-----------------------------------------------------------------------------
-- Main
-----------------------------------------------------------------------------
class Main
  start : int
  stop : int
  prime_array : PrimeArray
  f1 : Filter
  f2 : Filter
  f3 : Filter

  def main() : void 
    -- Requirement: vec_size * 4 > number_of_actors^2
    let vec_size = 1024*1024 in
      this.init(0, vec_size)

  def set_bound(start : int, stop : int) : void {
      this.start = start;
      this.stop = stop;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(stop - start);
    }

  def init(start : int, stop : int) : void
    let size = stop - start in { 
      this.set_bound(start, stop);
      -- Setup the filters // number is hardcoded for now
      this.f1 = new Filter;
      this.f2 = new Filter;
      this.f3 = new Filter;
      -- Stack them so they only send to `later' actors
      this.f1.set_bound(stop, stop + size);
      this.f2.set_bound(stop + size, stop + size + size);
      this.f3.set_bound(stop + size + size, stop + size + size + size);
      -- Start the computation
      this.filter(3);
      print 2;
      this.post_result(this.prime_array, this.start, 3);
      this.f1.get_report(this);
      this.f2.get_report(this);
      this.f3.get_report(this);
      ();
    }

  def filter(start : int) : void
      let i = start in 
        while i < this.stop
          {
	    -- this.prime_array.puts_debug("Considering", i);
            if this.prime_array.is_not_flagged(i) then {
              this.pass_on(i); 
              this.remove_simple(i);
            } else ();
            i = i + 2;
          }

  def remove_simple(value : int) : void 
    let i = value + value in
      while i < (this.stop - this.start)
        {
	  this.prime_array.report_work();
          this.prime_array.flag(i);
          i = i + value;
        }

  def pass_on(value : int) : void {
    this.f1.remove(value); 
    this.f2.remove(value); 
    this.f3.remove(value); 
    ();
    }

  def post_result(a : PrimeArray, offset : int, start : int) : void {
    a.puts_debug("Work", a.get_work_report());
    let i = start in
      while i < this.stop 
        {
          if a.is_not_flagged(i) then this.prime_array.puts(i + offset) else ();
          i = i + 2;
        }
    }


-----------------------------------------------------------------------------
-- Filter
-----------------------------------------------------------------------------
class Filter
  start : int
  stop : int
  prime_array : PrimeArray

  def set_bound(start : int, stop : int) : void {
      this.start = start;
      this.stop = stop;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(stop - start);
    }

  def remove(value : int) : void {
    -- this.prime_array.puts_debug("Cancelling", value);
    let m = this.prime_array.bit_index(this.start, value) in 
      let i = m in
        while i < (this.stop - this.start)
          {
            this.prime_array.report_work();
            this.prime_array.flag(i);
            i = i + value;
          }
    }

  def get_report(report_to : Main) : Fut void 
    report_to.post_result(this.prime_array, this.start, 1)
