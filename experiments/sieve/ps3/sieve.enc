-----------------------------------------------------------------------------
-- Dummy class for embedding
-----------------------------------------------------------------------------
passive class Void

-----------------------------------------------------------------------------
-- PrimeArray
-----------------------------------------------------------------------------
passive class PrimeArray
  data : Void 
  def flag(index : int) : void
    let bs = this.data in 
      embed void
        set((bitset*) #{bs}, #{index});
      end
  def unflag(index : int) : void
    let bs = this.data in 
      embed void
        unset((bitset*) #{bs}, #{index});
      end
  def is_not_flagged(index : int) : bool 
    let bs = this.data in 
      embed bool
        !isset((bitset*) #{bs}, #{index});
      end
  def set_size(size : int) : void 
    this.data = embed Void
        (Void_data*) mkBitset(0);
    end
  def bit_index(a : int, b : int) : int 
    embed int
      (#{a} % #{b}) ? ((#{a}/#{b})+1) * #{b} - #{a} : 0;
    end
  def even(a : int) : bool
    embed bool
      #{a} % 2 == 0;
    end
  def mod(a : int, b : int) : int
    embed int
      #{a} % #{b};
    end
  def puts_debug(s : string, i : int) : void
    embed void
      fprintf(stderr, "%s: %lld\n", #{s}, #{i});
    end
  def puts_debug4(s1 : string, i1 : int, s2 : string, i2 : int) : void
    embed void
      fprintf(stderr, "%s: %lld %s: %lld\n", #{s1}, #{i1}, #{s2}, #{i2});
    end
  def or(a : bool, b : bool) : bool 
    if a then 
      true
    else
      b
  def calculate_index(value : int, start : int, size : int) : int {
    embed int
int64_t S = #{start};
int64_t L = #{size};
int64_t E = S + L * 2;
int64_t V = #{value};
int64_t O;
if (S % V == 0) {
  O = 0;
} else {
  int64_t VV = (S/V+1)*V;
  if (VV %2 == 0) {
    VV += V;
  }
  if (S <= VV && VV <= E) {
    int64_t Z = VV-S;
    if (Z < L) {
      O = Z/2;
    } else {
      O = -1;
    }
  } else {
    O = -1; 
  }
}
//fprintf(stderr, "For value %lld and start %lld and stop %lld, we calculated index %lld\n", V, S, E, O);
O;
    end
    }
-----------------------------------------------------------------------------
-- Buffer
-----------------------------------------------------------------------------
passive class Buffer
  size : int
  max_size : int
  data : int -- Ouch!
  fc : int -- Ouch!
  def init(m : int) : void 
    embed void 
      this->size = 0;
      this->fc = 0;
      this->max_size = #{m};
      this->data = (int64_t) pony_alloc(sizeof(int64_t) * this->max_size); 
    end
  def full() : bool
    embed bool this->size == this->max_size; end
  def add(v : int) : void
    embed void ((int64_t*)this->data)[this->size++] = v; end
  def take(i : int) : int
    embed int ((int64_t*)this->data)[i]; end
  def size() : int
    embed int this->size; end
  -- def free() : void {
  --   this.fc = this.fc + 1;
  --   if this.fc == 3 then {
  --     embed void free((int64_t*) this->data); end
  --   } else ();
  --   }
    

passive class BufferEncore
  data : int
  size : int
  max_size : int
  def init(m : int) : void {
    this.size = 0;
    this.max_size = 1;
  }
  def full() : bool
    if this.size < this.max_size then false else true
  def add(v : int) : void {
    this.data = v;
    this.size = 1
  }
  def take(i : int) : int
    this.data
  def size() : int
    if this.full() then 1 else 0

-----------------------------------------------------------------------------
-- Main
-----------------------------------------------------------------------------
class Main
  start : int
  size : int
  prime_array : PrimeArray
  f1 : Filter
  f2 : Filter
  f3 : Filter
  buffer : Buffer
  buffer_size : int
  buffer_size_first : int

  def main() : void 
    -- Requirement: vec_size * 4 > number_of_actors^2
    let vec_size = 8 in
      this.init(vec_size)

  def set_bound(start : int, size : int) : void {
      this.start = start;
      this.size = size;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(size);
    }

  def init(size : int) : void { 
    this.buffer_size       = 1024;
    this.buffer_size_first = 4*1024;
      this.buffer = new Buffer;
      this.buffer.init(this.buffer_size_first);
      this.set_bound(3, size);
      -- Setup the filters // number is hardcoded for now
      this.f1 = new Filter;
      this.f2 = new Filter;
      this.f3 = new Filter;
      -- Stack them so they only send to `later' actors
      this.f1.set_bound((size * 2) + 3, size);
      this.f2.set_bound((size * 4) + 3, size);
      this.f3.set_bound((size * 6) + 3, size);
      -- Start the computation
      this.filter();
      print 2;
      this.post_result(this.prime_array, this.start);
      this.f1.get_report(this);
      this.f2.get_report(this);
      this.f3.get_report(this);
      ();
    }

  def filter() : void {
    let value = this.start in
    let offset = 0 in 
      while offset < this.size
        {
          if this.prime_array.is_not_flagged(offset) then {
	    if value < 0 then this.prime_array.puts_debug("Negative", value) else ();
            this.pass_on(value, false);
            this.remove_simple(offset, value);
          } else {
              ();
          }; 
          offset = offset + 1;
          value = value + 2;
        };
        this.pass_on(0-1, true); -- this number will be ignored 
     }

  def remove_simple(offset : int, value : int) : void {
    let offset = offset + value in
      while offset < this.size
        {
          this.prime_array.flag(offset);
          offset = offset + value
        }
    }

  def pass_on(value : int, flush : bool) : void {
    this.prime_array.puts_debug4("Supposed to buffer", value, "with flush being", if flush then 1 else 0);
    let buffered = true in 
      if buffered then {
       if this.buffer.full() then flush = true else ();
       this.prime_array.puts_debug4("Buffer full?", if this.buffer.full() then 1 else 0, "when size", this.buffer.size);
       if flush then { 
	 this.prime_array.puts_debug("Sending buffer of size", this.buffer.size);
         this.f1.remove_buffer(this.buffer); 
         this.f2.remove_buffer(this.buffer); 
         this.f3.remove_buffer(this.buffer); 
         this.buffer = new Buffer;
         this.buffer.init(this.buffer_size);
         if value > 0 then this.buffer.add(value) else ();
       } else {
	 this.prime_array.puts_debug("Adding to buffer", value);
         this.buffer.add(value);
       }
    } else {
      if value < 0 then () else {
        this.f1.remove(value); 
        this.f2.remove(value); 
        this.f3.remove(value); ()
      }
    }
  }

  def post_result(a : PrimeArray, start : int) : void 
    let value = start in
    let i = 0 in
      while i < this.size 
        {
          if a.is_not_flagged(i) then print value else ();
          i = i + 1;
          value = value + 2;
        }

-----------------------------------------------------------------------------
-- Filter
-----------------------------------------------------------------------------
class Filter
  start : int
  size : int
  prime_array : PrimeArray

  def set_bound(start : int, size : int) : void {
      this.start = start;
      this.size = size;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(size);
    }

  def remove_buffer(b : Buffer) : void {
    this.prime_array.puts_debug("Getting a buffer of size", b.size); 
    let i = 0 in 
      while i < b.size {
	let v = b.take(i) in if v == 0 then () else { this.remove(v);
        this.prime_array.puts_debug("Buffer contains", v); 
	  };
        i = i + 1;
	};
        --b.free();
    }

  def remove(value : int) : void 
    let I = this.prime_array.calculate_index(value, this.start, this.size) in
      if I < 0 then () else this.do_remove(I, value) 

  def do_remove(offset : int, value : int) : void
    while offset < this.size 
      {
        this.prime_array.flag(offset);
	offset = offset + value;
      }

  def remove_old(value : int) : void {
    --this.prime_array.puts_debug("Value", value);
    let i = 
      let offset = this.start / value in {
        if this.prime_array.mod(this.start, value) == 0 then 0 else {
          let fst = ((offset + 1) * value) in
            if this.prime_array.even(fst) then (fst + value - this.start) / 2 else (fst - this.start) / 2} } in {
              while i < this.size
                {
                  this.prime_array.flag(i);
                  i = i + value;
                };
      }
    }

  def get_report(report_to : Main) : Fut void 
    report_to.post_result(this.prime_array, this.start)


