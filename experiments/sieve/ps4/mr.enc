embed
#include <string.h>
#include "bitset.h"
#include "set.h"
int64_t calculate_offset(int64_t S, int64_t L, int64_t V) {
//  L *= 2;
  if (!V) return -1;
  int64_t E = S + L;
  int64_t O;
  if (S % V == 0) {
    O = 0;
  } else {
    int64_t VV = (S/V+1)*V;
    if (VV %2 == 0) {
      VV += V;
    }
    if (S <= VV && VV <= E) {
      int64_t Z = VV-S;
      if (Z < L) {
        O = Z/2;
      } else {
        O = -1;
      }
    } else {
      O = -1; 
    }
  }
  // fprintf(stderr, "For value %lld and start %lld and stop %lld, we calculated index %lld\n", V, S, E, O);
  return O;
}

bool is_prime(int64_t n) {
  for(int i=2;i<=n/2;++i)
  {
      if(n%i==0)
      {
          return false;
      }
  } 
  return true;
}
end

passive class Cheat
  v : Filter
  def init(v:Filter) : void
    this.v = v

passive class Data

passive class List
  data : Data
  size : int

  def init() : void
    embed void
      this->size = 0;
      this->data = calloc(sizeof(int64_t), 1024*1024);
    end
  def appendAll(other:List) : void
    embed void
      int new_size = this->size + other->size;
      for (int i = this->size; i < new_size; ++i) this->data[i] = other->data[i];
      this->size = new_size;
    end
    
  def append_from(value:int, from:int) : void
    printf "{} from {}\n", value, from

  def append(value:int) : void
    embed void
      printf("%lld\n", value);
      // if (is_prime(value)) {
      // } else {
      // 	 printf("Adding a non-prime: %lld\n", value);
      // }
      ((int64_t*)this->data)[this->size++] = (int64_t *)value;
    end

  def size() : int
    this.size

  def dump() : void 
    ()
    -- embed void
    --   for (int i = 0; i < this->size; ++i) 
    --     printf("%lld\n", this->data[i]);
    -- end


passive class Bitset
  data : int
  size : int

  def init(size:int) : void
    embed void
      this->size = size;
      this->data = (int64_t) mkBitset(0);
    end

  def isset(index:int) : bool
    embed bool
      !isset((bitset*) this->data, #{index});
    end

  def set(index:int) : void
    embed void
      unset((bitset*) this->data, #{index});
    end

  def unset(index:int) : void
    embed void
      set((bitset*) this->data, #{index});
    end

passive class Utility
  result : List
  def init() : void 
    this.result = let t = new List in { t.init(); t }

  def actors_for_depth(depth:int) : int
    let actors = 1 in 
      let size = 1 in {
	while depth > 1 {
          size = size * 2;
          depth = depth - 1;
          actors = actors + size;
	};
	actors
      }

  def actor_size(size:int, depth:int) : int
    let actors = this.actors_for_depth(depth) in size / actors

  def true_size(size:int, depth:int) : int
    let actors = this.actors_for_depth(depth) in size - size % actors + 3

  def report(primes:List) : void
    this.result.appendAll(primes)

  def print_result() : void
    this.result.dump()

class Filter
  id      : int
  parent  : Cheat
  left    : Filter
  right   : Filter
  start   : int
  size    : int
  primes  : Bitset
  utility : Utility

  def init(id:int, size:int, depth:int, parent:Cheat, u:Utility) : void {
    this.parent = parent;
    this.setup(id, size);
    this.utility = u;

    if depth > 1 then let self = let t = new Cheat in { t.init(this); t } in {
      this.left = let t = new Filter in { t ! init(id + 1, size, depth - 1, self, u); t };
      this.right = let t = new Filter in { t ! init(id + 1 + u.actors_for_depth(depth - 1), size, depth - 1, self, u); t };
    } else { (); }
  }

  def setup(id:int, size:int) : void {
    this.id = id;
    this.start = id * size * 2 + 3;
    this.size = size;
    if this.start % 2 == 0 then {
      this.start = this.start + 1;
      this.size = this.size - 1;
    } else { (); };
    this.primes = let t = new Bitset in { t.init(this.size); t };
  }

  def filter() : void 
    let size = this.size / 2 in
    let i = 0 in {
      while i < size {
        if this.primes.isset(i) then {
          this.cancel(this.start + i * 2);
          this.primes.set(i);
        } else { (); };
        i = i + 1;
      }
  }

  def cancel(prime:int) : void {
    if this.left == null then { (); } else {
      this.left ! cancel(prime);
      this.right ! cancel(prime);
    };
	    
    let i = this.calculate_offset(this.start, this.size, prime) in {
      -- printf "Cancelling {} with offset {} in {}\n", prime, i, this.id;
      if i < 0 then { (); } else {
        while i < this.size {
          this.primes.unset(i);
          i = i + prime;
        };
      };
    }
  }

  def done() : void 
    let primes = let t = new List in { t.init(); t } in 
      let prime = this.start in {
        let i = 0 in 
          while i < this.size {
	    if this.primes.isset(i) then primes.append(prime) else ();
            prime = prime + 2;
	    i = i + 1;
	  };
        this.report(primes);
        if this.left == null then () else this.left ! done();
        if this.right == null then () else this.right ! done();
    }

  def report(primes:List) : void 
    if this.parent == null then this.utility.report(primes) else this.parent.v ! report(primes)
        
  def calculate_offset(start:int, size:int, prime:int) : int 
    embed int
      calculate_offset(#{start}, #{size}, #{prime});
    end

class Main 
  def main() : void {
    let u = let t = new Utility in { t.init(); t } in 
    let candidates_approx = 1000 in
    let depth = 2 in
    let size = u.actor_size(candidates_approx, depth) in 
    let candidates_true = u.true_size(candidates_approx, depth) in 
    let f = let t = new Filter in { get t.init(0, size, depth, null, u ); t } in {
      print "2";
      f.filter();
      let barrier = f.done() in get barrier;
      u.print_result()
    }
  }

