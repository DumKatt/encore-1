embed
#include "bitset.h"
#include "set.h"
// Ugly hack which generates a warning but solves Issue 16
// https://github.com/parapluu/mylittlepony/issues/16
// typedef struct ___Filter_data Filter_data;

int64_t calculate_start_offset(int64_t S, int64_t L, int64_t V) {
  if (!V) return -1;
  int64_t E = S + L;
  int64_t O;
  if (S % V == 0) {
    O = 0;
  } else {
    int64_t VV = (S/V+1)*V;
    if (VV %2 == 0) {
      VV += V;
    }
    if (S <= VV && VV <= E) {
      int64_t Z = VV-S;
      if (Z < L) {
        O = Z/2;
      } else {
        O = -1;
      }
    } else {
      O = -1; 
    }
  }
  // fprintf(stderr, "For value %lld and start %lld and stop %lld, we calculated index %lld\n", V, S, E, O);
  return O;
}
end

class VoidStar

-- TODO: size of work should be controlled by filling buffers, not splitting up-front
passive class Set_of_Ints
  set_ptr : VoidStar -- ouch!
  size : int
  def init() : void
    embed void
      this->size = 0;
      this->set_ptr = calloc(sizeof(int64_t), 1024); //(pony_actor_t *)mk_set(); 
      assert(this->set_ptr);
    end
  def add(v:int) : void
    embed void
      ((int64_t *)this->set_ptr)[this->size++] = #{v};
      //set_t *set = (set_t *)this->set_ptr;
      //set_add(set, (void *)#{v});
    end
  def for_all_ints(c: int -> void) : void
    embed void
      if (this->set_ptr) {
        for (int i = 0; i < this->size; ++i) {
          value_t argv[1] = {{ .integer = ((int64_t *)this->set_ptr)[i] }};
          closure_call(c, argv);
          //printf("%ld when i=%d\n", argv[0].integer, i);
        }
      } else {
        printf("!!!!!!!!!!!!!!! %p\n", c);
      }
      // set_t *set = (set_t *)this->set_ptr;
      // set_forall_closure(set, #{c});
    end
passive class Set_of_Filters
  set_ptr : VoidStar -- ouch!
  size : int
  def init() : void
    embed void
      this->size = 0;
      this->set_ptr = calloc(sizeof(pony_actor_t*), 1024); //(pony_actor_t *)mk_set(); 
    end
    -- embed void
    --   this->set_ptr = (pony_actor_t *)mk_set(); 
    -- end
  def add(p:PFilter) : void
    embed void
      ((pony_actor_t **)this->set_ptr)[this->size++] = #{p};
    end
    -- embed void
    --   set_t *set = (set_t *)this->set_ptr;
    --   set_add(set, (void *)#{p});
    -- end
  def for_all(c:PFilter -> void) : void
    embed void
      for (int i = 0; i < this->size; ++i) {
        value_t argv[1] = {{ .ptr = ((pony_actor_t **)this->set_ptr)[i] }};
        closure_call(c, argv);
      }
    end
    -- embed void
    --   set_t *set = (set_t *)this->set_ptr;
    --   set_forall_closure(set, #{c});
    -- end
passive class Filter
  start : int
  size : int
  data : VoidStar -- ouch!
  id : int
  def init(id : int, start:int, filter_size:int) : Filter {
    this.id = id;
    this.start = start;
    this.size = filter_size;
    embed void
      this->data = (pony_actor_t *)mkBitset(0);
    end;
    this;
    }
  def is_not_flagged(index:int) : bool
    embed bool
      !isset((bitset*) this->data, #{index});
    end
  def flag(index:int) : void
    embed void
      set((bitset*) this->data, #{index});
    end
  def cancel(prime:int) : void
    let i = this.calculate_start_offset(prime, this.start, this.size) in
      if i < 0 then () else 
        while i < this.size {
          this.flag(i);
          i = i + prime;
        }
  def calculate_start_offset(prime:int, start:int, size:int) : int -- TODO: replace with encore
    embed int
      calculate_start_offset(#{start}, #{size}, #{prime});
    end

class PFilter
  filter : Filter
  def init(id:int, start:int, size:int) : void 
    this.filter = let f = new Filter in f.init(id, start, size)
  -- note that the fix indirection is necessary due to issue 18
  -- https://github.com/parapluu/mylittlepony/issues/18
  def do_work(primes:Set_of_Ints) : void 
    let fix = this.filter in -- HERE!
      let action = \(i:int) -> { fix.cancel(i); (); } in 
        primes.for_all_ints(action)
  def report(receiver:Main) : Fut void 
    let f = this.filter in 
      receiver.receive_report(f)
class Main
  filter : Filter
  pfilters : Set_of_Filters
  start : int
  def printa(s:string,i1:int,i2:int) : void
    embed void
      //fprintf(stdout, "%lld\n", #{i2});
      fprintf(stdout, "%lld %s %lld\n", #{i1}, #{s}, #{i2});
    end
  def main() : void
    this.init(4, 16*1024*1024*2, 1024*512*2)
  def init(no_filters : int, candidates : int, buffer_size : int) : void {
    let filter_size = candidates / no_filters in {
      embed void 
        assert(#{candidates} > #{no_filters} * #{no_filters});
        //assert(#{filter_size} * #{no_filters} == #{candidates});
        assert(#{candidates} % #{buffer_size} == 0);
        assert(#{filter_size} % 2 == 0);
        assert(#{buffer_size} <= #{filter_size});
      end;
      this.filter = new Filter;
      this.pfilters = new Set_of_Filters;
      this.pfilters.init();
      this.start = 3;
      this.filter.init(0, this.start, filter_size);
      let start = this.start + filter_size * 2 in {
        let i = 1 in {
          while i < no_filters {
            let f = new PFilter in {
              f.init(i, start, filter_size);
              this.pfilters.add(f);
              start = start + filter_size * 2;
              i = i + 1;
              }}}};
      print 2;
      let index = 0 in {
        while index < filter_size {
          this.do_work(index, buffer_size);
          index = index + buffer_size;
          }}};
      -- print "*********************************************";
      -- note that the fix indirection is necessary due to issue 18
      -- https://github.com/parapluu/mylittlepony/issues/18
      let fix = embed Main
		  (Main_data *)this->aref;
	        end in
        let action = \(f : PFilter) -> { f.report(fix); (); } in 
          this.pfilters.for_all(action); 
      }
  def do_work(start_index : int, amount : int) : void {
    let primes = new Set_of_Ints in {
      primes.init();
      let i = 0 in 
        while i < amount
          {
            if this.filter.is_not_flagged(i + start_index) then {
	      print this.start;
              this.filter.cancel(this.start);
              primes.add(this.start);
            } else { (); };
            this.start = this.start + 2;
            i = i + 1;
          };
        if primes.size > 0 then 
        let action = \(f : PFilter) -> { f.do_work(primes); (); } in 
          this.pfilters.for_all(action)
        else ();
        }
      }
  def receive_report(f : Filter) : void {
    --this.printa("receive_report", f.start, f.start+f.size);
    let value = f.start in 
      let i = 0 in 
        while i < f.size 
          {
            if f.is_not_flagged(i) then print value else ();
            i = i + 1;
	    value = value + 2
          }}

-- Flera parallella filter tycks skriva ut samma värde
-- Samtliga filter anser att de värden som skriv ut är inom deras intervall
-- Alla filter har olika interval
