-----------------------------------------------------------------------------
-- Dummy class for embedding
-----------------------------------------------------------------------------
passive class Void

-----------------------------------------------------------------------------
-- PrimeArray
-----------------------------------------------------------------------------
passive class PrimeArray
  data : Void 
  def flag(index : int) : void
    let bs = this.data in 
      embed void
	set((bitset*) #{bs}, #{index});
      end
  def unflag(index : int) : void
    let bs = this.data in 
      embed void
	unset((bitset*) #{bs}, #{index});
      end
  def is_not_flagged(index : int) : bool 
    let bs = this.data in 
      embed bool
	!isset((bitset*) #{bs}, #{index});
      end
  def set_size(size : int) : void 
    this.data = embed Void
        (Void_data*) mkBitset(0);
    end
  def bit_index(a : int, b : int) : int 
    embed int
      (#{a} % #{b}) ? ((#{a}/#{b})+1) * #{b} - #{a} : 0;
    end

-----------------------------------------------------------------------------
-- Main
-----------------------------------------------------------------------------
class Main
  start : int
  stop : int
  prime_array : PrimeArray
  f1 : Filter
  f2 : Filter
  f3 : Filter

  def main() : void 
    -- Requirement: vec_size * 4 > number_of_actors^2
    let vec_size = 1024*1024 in
      this.init(0, vec_size)

  def set_bound(start : int, stop : int) : void {
      this.start = start;
      this.stop = stop;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(stop - start);
    }

  def init(start : int, stop : int) : void
    let size = stop - start in { 
      this.set_bound(start, stop);
      -- Setup the filters // number is hardcoded for now
      this.f1 = new Filter;
      this.f2 = new Filter;
      this.f3 = new Filter;
      -- Stack them so they only send to `later' actors
      this.f1.set_bound(stop, stop + size);
      this.f2.set_bound(stop + size, stop + size + size);
      this.f3.set_bound(stop + size + size, stop + size + size + size);
      -- Start the computation
      this.prime_array.flag(1);
      this.filter(2);
      this.post_result(this.prime_array, this.start, 2);
      this.f1.get_report(this);
      this.f2.get_report(this);
      this.f3.get_report(this);
      ();
    }

  def filter(start : int) : void
    let i = start in 
      while i < this.stop
	{
	  if this.prime_array.is_not_flagged(i) then {
            this.pass_on(i);
            this.remove_simple(i);
          } else ();
          i = i + 1
        }

  def remove_simple(value : int) : void 
    let i = value + value in
      while i < (this.stop - this.start)
        {
	  this.prime_array.flag(i);
          i = i + value;
        }

  def pass_on(value : int) : void {
    this.f1.remove(value); 
    this.f2.remove(value); 
    this.f3.remove(value); 
    ();
    }

  def post_result(a : PrimeArray, offset : int, start : int) : void 
    let i = start in
      while i < this.stop 
        {
    	  if a.is_not_flagged(i) then print i + offset else ();
          i = i + 1;
        }


-----------------------------------------------------------------------------
-- Filter
-----------------------------------------------------------------------------
class Filter
  start : int
  stop : int
  prime_array : PrimeArray

  def set_bound(start : int, stop : int) : void {
      this.start = start;
      this.stop = stop;
      this.prime_array = new PrimeArray;
      this.prime_array.set_size(stop - start);
    }

  def remove(value : int) : void 
    let m = this.prime_array.bit_index(this.start, value) in 
      let i = m in
        while i < (this.stop - this.start)
          {
  	    this.prime_array.flag(i);
            i = i + value;
          }

  def get_report(report_to : Main) : Fut void 
    report_to.post_result(this.prime_array, this.start, 0)
