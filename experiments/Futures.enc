class SqFuture

  -- A SqFuture is an actor. It models an asynchronous Sq-call to a
  -- server and allows to carry a context along.

  -- When a SqFuture is spawned, it'll tell the server to do the
  -- work.  After the server is done, it'll inform the Future of its
  -- termination (via a `fulfill` message, threading back the context.).
  
  -- When created, a SqFuture will tell the server to do its job and
  -- ask for the return value
  server:Server
  subsc_ctx:VoidPtr
  subsc_actor:Main
  val:int
  has_val:int

  def add_subscriber(subsc_actor:Main,subsc_ctx:VoidPtr) : void {
    this.subsc_actor = subsc_actor;
    this.subsc_ctx = subsc_ctx
  }
    
  def spawn(srv: Server, n:int) : void {
    this.server = srv;
    this.has_val = 0;
    this.server.sq(n,this)
  }

  def fulfill(sq:int) : void {
    this.has_val = 1;
    this.val = sq;
    this.inform_subscribers()
  }

  def inform_subscribers() : void
    this.subsc_actor.tell(this.val, this.subsc_ctx)
    
class VoidPtr
  -- empty class, I'll use references to this
  -- class when I need void*

class SqFuturePtr
  -- empty class, I'll use references to this
  -- class when I need SqFuture_data*

class Main
  def main() : void {
    let i = 2 in {
      while i > 0 {
        let srv = new Server in {
          -- this is where we create our 'call':
          -- first, we're manually making a future, add ourselves as subscriber, and
          -- then let it loose by calling spawn:
          let f = new SqFuture in {
            f.add_subscriber(this, embed VoidPtr NULL end);
            f.spawn(srv, i*10) -- "call"
          }
        };
        i = i-1
      }
    }
  }

  def tell(val:int, ctx:VoidPtr) : void {
    print "got";
    print val
  }

class Server
  def sq(n:int,f:SqFuture) : void {
    print "hmmm..";
    embed 
      void sleep(5) 
    end;
    print "I got it!";
    f.fulfill(n*n)
  }

