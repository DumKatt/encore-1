--- The following are available to the programmer.
import Utils
-- The value that signals the stop of a computation. 
-- stop :: Par T
def stop() : ParT {
  let r = new ParT in 
    r.mkS();
}


-- "Upcast" a future value into a (singleton) parallel computation.
-- lift :: Fut x -> Par x
def lift(x : Fut int) : ParT {
  let r = new ParT in 
    r.mkF(x);
}

-- "Upcast" a value into a (singleton) parallel computation.
-- parone :: x -> Par x
def parone(x : int) : ParT {
  let r = new ParT in 
    r.mkV(x);
}


-- (|) :: Par x -> Par x -> Par x
def par(x : ParT, y : ParT) : ParT {
  let r = new ParT in 
    r.mkP(x,y);
}


-- >>= :: Par x -> (x -> Par y) -> Par y
def bind(x : ParT, f : int -> ParT) : ParT {
  if x.isS() then stop()
  else if x.isV() then f(x.val())
  else if x.isF() then f(get x.future())    -- should use chaining
  else par(bind(x.left(), f), bind(x.right(), f) )
}

-- Wait for one value to finish and kill any remaining parallel computations.
-- primprune :: Par t -> t
-- Note: the real definition of this would need to
-- 1) pick the first to finish
-- 2) actually kill of the others.
-- 3) What happens if there is nothing there? Currently, returns null

def primprune(x : ParT) : int {
  if x.isS() then -1
  else if x.isV() then x.val()
  else if x.isF() then get x.future()
  else 
    let y = primprune(x.left()) in 
    if y != -1 then y else primprune(x.right())
}



-- Orc's pruning 
-- (<<) :: (t -> Par t') -> Par t -> Par t'
-- this should run the two argument functions
-- in parallel. But doesn't
-- A more refined type would be something like (Fut t -> Par t') -> Par t -> Par t'
-- where the future captures the result of pruning the second argument

def prune(f : int -> ParT, x : ParT) : ParT {
  let res = primprune(x) in 
  if res == -1 then stop() else f(res)
}


-- A "lambda guarded" value of type t
-- type Delay t = () -> t
-- otherwise: if first argument is Stop, use second argument
-- (\\) :: Par t -> Delay (Par t) -> Par t

def otherwise(x : ParT, d : () -> ParT) : ParT {
   -- deep check whether x is stop
   if isNothing(x) then d () else x
}

def isNothing(x : ParT) : bool {
  if x.isS() then true
  else if x.isV() then false
  else if x.isF() then false
  else (isNothing(x.left()) and isNothing(x.right()))
}

def pmap(f : int -> int, x : ParT) : ParT {
  if x.isS() then stop()
  else if x.isV() then parone(f(x.val()))
  else if x.isF() then parone(f(get x.future()))    -- should use chaining
  else par(pmap(f, x.left()), pmap(f, x.right()) )
}

-- List<T> != List<Fut T>
-- In the future we could imagine doing this operation
-- over any kind of collection.
def each(l: List<int>): ParT {
  if (l.size()==0) then { 
    stop();
  } else {
    let party = parone(l.pop()) in {
      while(l.size() != 0) {
        party = par(party, parone(l.pop()));
      };
      party
    }
  }
}

def sync_part(l: List<int>, p: ParT): List<int> {
  if p.isS() then l
  else if p.isV() then l.push(p.val())
  else if p.isF() then l.push(get p.future())
  else {
    sync_part(l, p.left());
    sync_part(l, p.right());
  }
}

def sync(p: ParT): List<int> {
  let l = new List<int> in {
    sync_part(l, p)
  }
}

--
-- data Par t = Stop                   -- empty structures
--             | V t                    -- a single value, here
--             | F (Fut t)              -- single value, not yet here
--             | P (Par t) (Par t)  -- par

passive class T  -- represents the type variable for ParT

passive class ParT {
  typetag : int
  -- union 
  -- S -- typetag == 0
  -- V -- typetag == 1
  valv : int
  -- F -- typetag == 2
  futurev : Fut int
  -- P -- typetag == 3
  leftv : ParT
  rightv : ParT

  def init() : ParT {
    -- can't do much here, maybe set everything to null
    this
  }
  
  -- S ops
  def mkS() : ParT {
    this.typetag = 0;
    this;
  }

  def isS() : bool {
     (this.typetag == 0);
  }

  -- V ops
  def mkV(x : int) : ParT {
    this.typetag = 1;
    this.valv = x;
    this;
  }

  def isV() : bool {
     (this.typetag == 1);
  }

  def val() : int {
     this.valv;
  }
   
  -- F ops
  def mkF(x : Fut int) : ParT {
    this.typetag = 2;
    this.futurev = x;
    this;
  }

  def isF() : bool {
     (this.typetag == 2);
  }

  def future() : Fut int {
     this.futurev;
  }  

  -- P ops
  def mkP(x : ParT, y : ParT) : ParT {
    this.typetag = 3;
    this.leftv = x;
    this.rightv = y;
    this;
  }

  def isP() : bool {
     (this.typetag == 3);
  }

  def left() : ParT {
     this.leftv;
  }

  def right() : ParT {
     this.rightv;
  }
}

class Main
  def main(): void
    print "Works"
